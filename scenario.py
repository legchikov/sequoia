from string import Formatter
from config import VERSION, PATH_BASELINES, PATH_CONFIGS


def multi(func):
    matrix = ['//Generated by Sequoia v.{}'.format(VERSION)]
    steps = []
    checksum = []

    def inner(*args):
        action = args[0]
        step = args[1]
        generator = args[2]
        chksum = None
        if len(args) == 4:
            chksum = args[3]

        steps.append(step)

        if action.name == 'SetStatic':
            header = action.header + ',' + ','.join('#'+str(x) for x in generator.keys())
            message = action.template.format(**generator, Step=step) + ',' + ','.join(str(x) for x in generator.values())

            matrix.append('')
            matrix.append(header)
            matrix.append(message)
        else:
            try:
                matrix.append('')
                matrix.append(action.header)
                for params in generator:
                    if chksum:
                        checksum.append(chksum(params))
                    params['Step'] = step
                    check_params(action.template, params.keys())
                    message = func(action, **params)
                    matrix.append(message)
            except AttributeError as e:
                print(e)
            except DoNotMatchError as e:
                print(e)
                print(e.unmatched)
                return

    return inner


@multi
def sc(action, **params):
    return action.template.format(**params)


def render(fn, store):
    if store == 'matrix':
        return fn.__closure__[2].cell_contents
    elif store == 'steps':
        return fn.__closure__[3].cell_contents
    elif store == 'checksum':
        return int(sum(fn.__closure__[0].cell_contents))


def check_params(action, generator_params):
    action_params = get_action_params(action)
    diff = set(action_params) - set(generator_params)

    if diff:
        raise DoNotMatchError(diff)


def get_action_params(action):
    return [fn for _, fn, _, _ in Formatter().parse(action) if fn is not None]


class DoNotMatchError(Exception):
    def __init__(self, unmatched):

        # Call the base class constructor with the parameters it needs
        super().__init__('Error: The following parameters do not match:')

        # list of unmatched parameters
        self.unmatched = '[' + ', '.join(unmatched) + ']'


def push(name, data, type):
    import os

    if type == 'baseline':
        filename = os.path.join(PATH_BASELINES, name + '_' + type + '.csv')
        with open(filename, 'w') as fout:
            fout.write("\n".join(data))
        print('File {} was successfully written'.format(filename))

    elif type == 'config':
        filename = os.path.join(PATH_CONFIGS, name + '_' + type + '.cfg')
        with open(filename, 'w') as fout:
            fout.write('Global step,Step kind,Start at,Start at type,Parameter,Ask for continue,Ask if failed,Execute,Comment\n')
            for line in data:
                fout.write(line + ',Default,,End of previous step,,1,0,1,' + '\n')
        print('File {} was successfully written'.format(filename))
