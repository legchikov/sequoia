from string import Formatter
from config import VERSION, PATH_BASELINES, PATH_CONFIGS, PATH_OUTPUT
from scheduler import SCHEDULER_HEADER, make_scheduler_config


def multi(func):
    matrix = ['//Generated by Sequoia v.{}'.format(VERSION)]
    scheduler_config = [SCHEDULER_HEADER]
    checksum = []

    def inner(*args):
        action = args[0]
        step = args[1]
        generator = args[2]
        chksum = None
        if len(args) == 4:
            chksum = args[3]

        scheduler_config.append(make_scheduler_config(step))

        if action.name == 'SetStatic':
            header = action.header + ',' + ','.join('#'+str(x) for x in generator.keys())
            message = action.template.format(**generator, Step=step) + ',' + ','.join(str(x) for x in generator.values())

            matrix.append('')
            matrix.append(header)
            matrix.append(message)
        else:
            try:
                matrix.append('')
                matrix.append(action.header)
                for params in generator:
                    if chksum:
                        checksum.append(chksum(params))
                    params['Step'] = step
                    check_params(action.template, params.keys())
                    message = func(action, **params)
                    matrix.append(message)
            except AttributeError as e:
                print(e)
            except DoNotMatchError as e:
                print(e)
                print(e.unmatched)
                return

    return inner


@multi
def sc(action, **params):
    return action.template.format(**params)


def render(fn, store):
    if store == 'matrix':
        return fn.__closure__[2].cell_contents
    elif store == 'scheduler_config':
        return fn.__closure__[3].cell_contents
    elif store == 'checksum':
        return int(sum(fn.__closure__[0].cell_contents))


def check_params(action, generator_params):
    action_params = get_action_params(action)
    diff = set(action_params) - set(generator_params)

    if diff:
        raise DoNotMatchError(diff)


def get_action_params(action):
    return [fn for _, fn, _, _ in Formatter().parse(action) if fn is not None]


class DoNotMatchError(Exception):
    def __init__(self, unmatched):

        # Call the base class constructor with the parameters it needs
        super().__init__('Error: The following parameters do not match:')

        # list of unmatched parameters
        self.unmatched = '[' + ', '.join(unmatched) + ']'


def push(name, data, type):
    import os

    if type == 'matrix':
        path = PATH_BASELINES
        name += '_baseline.csv'
    elif type == 'scheduler_config':
        path = PATH_CONFIGS
        name += '_config.cfg'
    else:
        path = PATH_OUTPUT
        print('Invalid type')

    filename = os.path.join(path, name)
    with open(filename, 'w') as fout:
        fout.write("\n".join(data))

    print('File {} was successfully written'.format(filename))

